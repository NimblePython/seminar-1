# Little endian / Big endian
Little-endian — это порядок байтов в памяти, где младший байт числа (наименее значимый) хранится в наименьшем адресе, а старший байт числа (наиболее значимый) хранится в старшем адресе.

### Пример

Представим число **0x12345678** (32-битное целое число). В двоичной системе оно выглядит так:

- **0x12** → `00010010` (старший байт)
- **0x34** → `00110100`
- **0x56** → `01010110`
- **0x78** → `01111000` (младший байт)

#### В памяти

- В **big-endian** (старший байт первым):  
  `12 34 56 78`

- В **little-endian** (младший байт первым):  
  `78 56 34 12`

### Пояснение

- В **little-endian**, младший байт находится по наименьшему адресу, так как система сохраняет байты "в обратном порядке".
  
Например, если адрес памяти начинается с **0x1000** и мы записываем число **0x12345678** в этот адрес по системе little-endian, то память будет выглядеть так:
  
| Адрес     | Данные (байт) |
| --------- | ------------- |
| **0x1000**| 78            |
| **0x1001**| 56            |
| **0x1002**| 34            |
| **0x1003**| 12            |

В этом случае, младший байт **0x78** хранится по адресу **0x1000**, старший байт **0x12** хранится по адресу **0x1003**.

### Почему так?

Архитектуры с little-endian (например, x86) делают так, чтобы младшие значимые байты оказывались в первых адресах памяти. Это удобно при обработке данных переменной длины, например, в арифметических операциях.

Пример обработки данных переменной длины с использованием little-endian можно увидеть на уровне работы с числами разных разрядностей (8, 16, 32 и 64 бит) на уровне побитовых операций. В этом случае доступ к младшим байтам числа облегчается, так как младшие байты всегда располагаются по более низким адресам.

### Пример: Сложение чисел переменной длины

Предположим, у нас есть система с архитектурой little-endian, и нам нужно выполнить сложение двух 16-битных чисел, хранящихся в памяти. Однако в процессе выполнения программы мы можем начать сложение с младших байтов (например, если мы выполняем сложение на 8-битном процессоре).

Допустим, два числа:

1. **0x1234**  
2. **0x5678**

### Память (Little-Endian)

- Число 0x1234 в памяти (16 бит):  
  | Адрес     | Данные (байт) |
  | --------- | ------------- |
  | **0x1000**| 34            |
  | **0x1001**| 12            |

- Число 0x5678 в памяти (16 бит):  
  | Адрес     | Данные (байт) |
  | --------- | ------------- |
  | **0x1002**| 78            |
  | **0x1003**| 56            |

Теперь, если процессор начинает обработку с младших байтов (которые находятся по адресу **0x1000** и **0x1002**), то ему не нужно учитывать длину чисел на этом этапе, так как данные обрабатываются в порядке от младшего байта к старшему.

### Сложение

Сначала процессор складывает младшие байты:

- **0x34 (из числа 0x1234)** + **0x78 (из числа 0x5678)**  
  Это складывание выполняется на младших байтах.

- Затем процессор обрабатывает перенос и складывает старшие байты:

- **0x12 (из числа 0x1234)** + **0x56 (из числа 0x5678)** + (перенос, если он был)  
  Это уже работа со старшими байтами.

### Почему Little-Endian Удобен?

#### 1. Простота доступа к младшим байтам

В little-endian системе младшие байты всегда находятся по младшим адресам. Это удобно для операций с числами переменной длины. Если вам нужно работать только с младшими байтами числа (например, если вы хотите только младший байт 32-битного числа), достаточно просто взять первый байт по наименьшему адресу, без необходимости учитывать полное число или выполнять сложные смещения в памяти.

#### 2. Расширение числа

При работе с числами меньшей длины (например, с 16-битными числами) в little-endian архитектуре расширение до числа большей длины (например, до 32 или 64 бит) происходит проще. Вы можете просто прочитать первые несколько байтов, а затем при необходимости прочитать следующие байты без смещения.

### Заключение

Little-endian архитектура упрощает операции с младшими байтами и поддерживает более гибкое обращение к данным переменной длины. Система может начать обработку с младших байтов и при необходимости добавлять старшие байты позже.
